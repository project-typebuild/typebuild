"""
This file is used to generate all prompts to be sent to LLMs
"""

import pandas as pd
import streamlit as st

def get_prompt_to_code(user_requirements, df=None):

    """
    This function takes in the sample data and user requirements and creates the system instruction and prompt to code.
    # Args
    - user_requirements: A string with the user requirements
    - df_sample: A pandas dataframe with sample data

    # Returns
    - messages: A list of dictionaries with the system instruction and prompt to code

    """
    if df is not None:
        df_sample = df.head(5).to_markdown()
        df_string = f"""SAMPLE DATA:
        Use the column names and data types when you are writing the functions
        ```{df_sample}```"""
    else:    
        df_string = "NOTE: No sample data provided"

    system_instruction_to_code = f"""
You are the python developer with an expertise in packages like streamlit, pandas, altair. Because of your expertise, a domain expert contacted you to create a streamlit app for them. After your meeting with the domain expert, you have noted down their requirements. 

In your collection of functions, you have the following functions, ready to use. 

AVAILABLE FUNCTIONS:

[ st.stop() - A streamlit function to stop the execution under the line ]
    
{df_string}

The Requirements are:
```
{user_requirements}
```

THINGS TO REMEMBER:
- The functions you are generating will be used in a larger scheme of things. so be responsible in generating functions
- If the user asks for a login page, sign up page. Ignore it, you are not responsible for that. There is a separate team for that.
- If a sample data is provided, use it to write better functions. You should be careful with the data types and column names
- If the user asks for a table, you should always use st.dataframe to display the table
- If a sample data is provided, then assume the data is stored in a streamlit session state variable called st.session_state.df
- You need to return the full code of the functions you are generating
- Do not write unnecessary print, st.write and success, info and warning messages in the functions.
- Do not return the available functions in the response. Your response should include only the newly generated functions
- You need to create one function for each feature in the app
- You need to have a main function that calls all the other functions
- Dont add the code 
    if __name__ == '__main__':
        main()
    
based on the above requirements, write concise code and don't forget to write the detailed docstrings, including the args, return etc
"""
    prompt_to_code = """
    CODE:
    """

    messages =[
                {"role": "system", "content": system_instruction_to_code},
                {"role": "user", "content": prompt_to_code}]

    st.session_state.last_request = messages
    return messages

# We are not sending the code to modify, just the description of the functions generated by LLM
def get_prompt_to_modify(change_requested, user_requirements, all_function_descriptions,df=None):

    """
    This function takes in the sample data and user requirements and creates the system instruction and prompt to code.
    # Args
    - change_requested: change requested by the user
    - user_requirements: initial user requirements
    - all_function_descriptions: descriptions of all the functions available
    - df_sample: A pandas dataframe with sample data

    # Returns

    - messages: A list of dictionaries with the system instruction and prompt to code

    """


    if df is not None:
        df_sample = df.head(5).to_markdown()
        df_string = f"""SAMPLE DATA:
        Use this data to write better functions
        ```{df_sample}```"""
    else:    
        df_string = ""

        
    system_instruction_to_modify = f"""
    You are the python developer with an expertise in packages like streamlit, pandas, altair. Because of your expertise, a domain expert contacted you to create a streamlit app for them. After your meeting with the domain expert, you have noted down their requirements. 

    In your collection of functions, you have the following functions, ready to use. 

    AVAILABLE FUNCTIONS:

    [ st.stop() - A streamlit function to stop the execution under the line
    {all_function_descriptions} 
        ]
        
    {df_string}

    The User Requirements are:
    ```{user_requirements}```

    THINGS TO REMEMBER:
    - You have a project where all the code is written, the user has requested for a modification.
    - You need to identify what functions to modify
    - You need to return the full code of the functions you are modifying
    - You need to identify what other subfunction the main function is calling. 
    - Return all the modified function(s) inside the delimiters ``` (three backticks)
    - You need to return the full code of the functions you are generating or modifying
    - If the user asks for a table, you should always use st.dataframe to display the table
    - Your task is to update the USER REQUIREMENTS to include the recent changes. You should focus on modifying only the REQUIREMENTS that are directly related to the requested modifications.
    - To clarify, if the modification request pertains to something like changing the color of the plot, you should adjust the particular requirement that is affected, rather than making changes to the entire list of requirements.    - Return the modified user requirements inside the delimiters ||| (three pipes)
    - You need to modify the docstrings of the functions you are modifying.

    The modification requested by the user is:
    {change_requested}
    """

    prompt_to_modify = f"""
    MODIFIED CODE AND USER REQUIREMENTS:
    """

    messages =[
                {"role": "system", "content": system_instruction_to_modify},
                {"role": "user", "content": prompt_to_modify}]

    return messages

